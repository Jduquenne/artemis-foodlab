# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Commands

```bash
npm run dev       # Start Vite dev server
npm run build     # TypeScript check + production build
npm run lint      # Run ESLint
npm run preview   # Preview production build
node scripts/generate-manifest.cjs  # Update assets-manifest.json (Run after adding images)
node scripts/generate-food-db.cjs   # Regenerate food-db.json from recipes-db.json
node scripts/generate-db.cjs        # Regenerate recipes-db.json (v1 — no foodId)
node scripts/generate-db-v2.cjs     # Regenerate recipes-db.json (v2 — with foodId + preparation)
```

There are no tests in this project.

The app deploys to GitHub Pages at `/artemis-foodlab/` (configured in `vite.config.ts`).

## Product context

**Artemis Foodlab** is a fully offline meal planning PWA. No external APIs — all data lives in the browser (IndexedDB via Dexie + localStorage). This is a production app intended for continuous use and evolution — not a POC. Architecture decisions must always favour scalability, maintainability, and clarity. If something looks like a bad practice, flag it.

## UI constraints

- **Fully responsive**: the app is used on PC, tablet, and smartphone. Every view must adapt correctly at all breakpoints. Use Tailwind responsive prefixes (`sm:`, `md:`, `lg:`) as the primary tool.
- **No-scroll layout**: the content inside the main `<Layout>` children must fit the viewport without scrolling. Keep content compact. Dense views use `h-[calc(100vh-Xpx)]`, `min-h-0`, `overflow-hidden` and similar constraints to avoid overflow.
- **Styling**: Tailwind utility classes are the default. Custom CSS (in `src/styles/` or inline `style={}`) is allowed and encouraged when Tailwind cannot express the desired result cleanly.
- **Language**: UI is in French.
- **No comments** in generated code.

## Architecture

### Layer structure

```
src/
├── core/           # Business logic, domain models, DB, utilities
├── features/       # Feature modules (recipes, planning, shopping)
└── shared/         # Shared components, hooks, store, utils
```

### Data flow

1. `core/domain/types.ts` — domain types (`Recipe`, `Ingredient`, `Food`, `Unit` enum, `IngredientCategory` enum, etc.)
2. `core/domain/categories.ts` — static category config (used for routing and display)
3. `core/data/recipes-db.json` — master recipe database (generated by `scripts/generate-db-v2.cjs`)
4. `core/data/food-db.json` — canonical food/ingredient dictionary (generated by `scripts/generate-food-db.cjs`)
5. `core/services/db.ts` — Dexie schema with one store: `planning` (MealSlot).
6. `shared/store/useMenuStore.ts` — Zustand store tracking `currentWeek`/`currentYear`/`currentWeekId` (persisted in localStorage), plus `initWeek()` which detects week transitions

### Routing (App.tsx)

```
/recipes                        → RecipeModule (category grid)
/recipes/category/:categoryId   → CategoryDetail
/recipes/detail/:recipeId       → RecipeDetail
/planning                       → PlanningModule (drag-and-drop weekly grid)
/shopping                       → ShoppingModule (aggregated shopping list)
```

Root `/` redirects to `/recipes`. Uses `HashRouter` for GitHub Pages compatibility.

### Key implementation notes

- **Week utilities**: `core/utils/dateUtils.ts` — ISO week ID generation (`getWeekId`, `getDaysOfWeek`) used by the store. `shared/utils/weekUtils.ts` — week navigation helpers for the planning UI (`getWeekNumber`, `getMonday`, `getWeekRange`).
- **Drag & Drop**: `@dnd-kit/core` used in `PlanningModule`. Each `MealSlot` is both a droppable target and a draggable source via a grip handle. Swap/move logic lives in `PlanningModule.handleDragEnd`.
- **Shopping logic**: `core/utils/shoppingLogic.ts` aggregates ingredients across planned meals, respecting units.
- **Asset manifest**: `scripts/generate-manifest.cjs` generates `core/data/assets-manifest.json` listing recipe images under `public/`. Run if adding new images.

### IndexedDB migrations (critical)

Any change to the Dexie schema (adding/removing stores, indexes, or fields used in queries) **requires a new schema version**. Never modify an existing `.version(n)` block — always add a new `.version(n+1)` with an `.upgrade()` migration to preserve existing user data. The current schema is at **version 5** (`core/services/db.ts`).

### Theming system (critical)

The app uses a **CSS variable-based theme** defined in `src/index.css`. Tailwind's `slate` color scale and `white` are remapped to warm food-palette values via `@theme inline`, so all `slate-*` and `white` utilities automatically follow the active theme.

**Color variables** (defined in `:root` for light, `.dark` for dark):

```
--slate-50  to --slate-900   warm stone/cream scale
--white                      warm off-white (#faf6ef) — unchanged between themes
```

**Dark mode** is class-based: `@custom-variant dark (&:where(.dark, .dark *))` in CSS; the `.dark` class is toggled on `<html>` by `ThemeProvider` (`src/shared/contexts/ThemeContext.tsx`). The toggle button lives in the header via `ThemeToggle` (`src/shared/components/ThemeToggle.tsx`).

**Rules:**

- **Never use `bg-white` alone** — always pair it with `dark:bg-slate-100` (card surfaces) or let the page-level `bg-slate-50` handle dark backgrounds.
- **Never add hardcoded hex colors** or Tailwind colors outside the `slate-*`/`orange-*` palette without being explicitly asked to add a new palette color.
- **Backdrop overlays** (modals, drawers) must use `bg-black/X` — never `bg-slate-900/X`, because `slate-900` becomes a light color in dark mode.
- **`white` is reserved for constant-light contexts** (`text-white` on orange buttons). Using `dark:bg-slate-100` is the correct way to create dark surfaces; never rely on `bg-white` resolving to a dark color.
- When adding new palette colors (only when explicitly requested), define them as CSS variables in both `:root` and `.dark` in `index.css`, then register them via `@theme inline`.
- On every scrolling page, use markscrolling on scroll event for overpass the scrolling + click problem

## Git workflow

When the user asks for a **commit**, respond with only the commit message text — do not run any git commands. Format: `feature: <description>` or `fix: <description>`. In English. Short, no bullet points, no technical details.

## TypeScript conventions

- **Enum variable names must be in English** — the string value can be in French, but the identifier must be English. Example: `MAINTENANCE = "Entretien"`, not `ENTRETIEN = "Entretien"`.

## Component & interface conventions

- **One component per file**: every component that uses hooks, has meaningful logic, or exceeds ~15 lines must live in its own file. Inline sub-components inside a module file are only acceptable for trivial, purely presentational wrappers with no hooks and no props interface.
- **Feature folder structure (strict)**: each feature folder contains **only** `XModule.tsx` at its root — the primary entry point routed from `App.tsx`. Every other file (sub-views, modals, cards, rows, detail pages) goes in `components/`. No exceptions: if it's not the Module, it belongs in `components/`.
- **File location**: feature-specific components go in `src/features/<feature>/components/`. Shared components go in `src/shared/components/` (split into `layout/` for app-shell components and `ui/` for generic reusable components).
- **Props interfaces**: always named `<ComponentName>Props` (e.g. `CategoryCardProps`), co-located in the same file as the component. Never use generic names like `interface Props`.
- **Domain/service interfaces**: shared data-model types belong in `core/domain/types.ts`. Service-layer types (e.g. `ConsolidatedIngredient`) stay in their service file. Never define domain types inside component files.
- **Static data**: JSON databases (`recipes-db.json`, `food-db.json`, `assets-manifest.json`, `recipes-ingredients.json`) live in `core/data/`. Scripts to regenerate them are in `scripts/`.
